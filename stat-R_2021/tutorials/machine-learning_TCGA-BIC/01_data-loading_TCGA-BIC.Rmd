---
title: "Tutorial: machine-learning with TGCA BIC transcriptome"
subtitle: "01. Data loading"
author: "Jacques van Helden"
date: '`r Sys.Date()`'
output:
  html_document:
    self_contained: no
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: "hide"
  ioslides_presentation:
    slide_level: 2
    self_contained: no
    colortheme: dolphin
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    smaller: yes
    toc: yes
    widescreen: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  revealjs::revealjs_presentation:
    theme: night
    transition: none
    self_contained: true
    css: ../slides.css
  slidy_presentation:
    smart: no
    slide_level: 2
    self_contained: yes
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: yes
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  powerpoint_presentation:
    slide_level: 2
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    toc: yes
font-import: http://fonts.googleapis.com/css?family=Risque
font-family: Garamond
transition: linear
editor_options: 
  chunk_output_type: console
---




```{r settings, include=FALSE, echo=FALSE, eval=TRUE}

options(width = 300)
# options(encoding = 'UTF-8')
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path = 'figures/pavkovic2019_',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")

options(scipen = 12) ## Max number of digits for non-scientific notation
# knitr::asis_output("\\footnotesize")

```



```{r libraries, echo=FALSE, eval=TRUE}
requiredLib <- c("knitr")
for (lib in requiredLib) {
  if (!require(lib, character.only = TRUE)) {
    install.packages(lib, )
  }
  require(lib, character.only = TRUE)
}

```


## Downloading and loading the data and metadata files

The preprocessed datasets are available on the course github repository. 

### A convenient function to download files only once

We will use the function `download_only_once()` that we defined in a previous course on data exploration. 

This function takes as input a base URL, a file name and a local folder. 

- It checks if the local folder already exists, and if not  creates it. 
- It then checks if the file is already present in this local folder, and if not downloads it. 

This facilitates the downloading of the different files required for the practical. Open the code box below and run the code in your R console.


```{r function_download_only_once}
#' @title Download a file only if it is not yet here
#' @author Jacques van Helden email{Jacques.van-Helden@@france-bioinformatique.fr}
#' @param url_base base of the URL, that will be prepended to the file name
#' @param file_name name of the file (should not contain any path)
#' @param local_folder path of a local folder where the file should be stored
#' @return the function returns the path of the local file, built from local_folder and file_name
#' @exportÂ©
download_only_once <- function(
  url_base, 
  file_name,
  local_folder) {

  ## Define the source URL  
  url <- file.path(url_base, file_name)
  message("Source URL\n\t",  url)

  ## Define the local file
  local_file <- file.path(local_folder, file_name)
  
  ## Create the local data folder if it does not exist
  dir.create(local_folder, showWarnings = FALSE, recursive = TRUE)
  
  ## Download the file ONLY if it is not already there
  if (!file.exists(local_file)) {
    message("Downloading file from source URL to local file\n\t", 
            local_file)
    download.file(url = url, destfile = local_file)
  } else {
    message("Local file already exists, no need to download\n\t", 
            local_file)
  }
  
  return(local_file)
}
```


### Exercise: data download

1. Use the function `download_only_once()` to download the BIC  transciptome data and metadata from the github web site and store it in a local folder (for example `~/m3-stat-R/TCGA-BIC_analysis`). 

Base URL: <https://github.com/DU-Bii/module-3-Stat-R/raw/master/stat-R_2021/data/TCGA_BIC_subset/>

Files : 

- Expression table (1000 top-ranking genes from differential analysis): 

    - File name: `BIC_log2-norm-counts_edgeR_DEG_top_1000.tsv.gz`

    - This file contains log2-transformed and standardised counts, with 1000 genes (rows) x 819 samples (columns)

- Metadata: 

    - File name: `BIC_sample-classes.tsv.gz`

    - This file indicates the status of the 3 marker genes traditionnally used to diagnose the breast cancer type, as well as the cancer class derived from these 3 markers
    - For more information, see the pre-processing report:  [import_TCGA_from_Recount.html](https://du-bii.github.io/study-cases/Homo_sapiens/TCGA_study-case/import_TCGA_from_Recount.html)


2. After having downloaded these files, load them in variables having the following names (for the sake of consistency with the course material). 

- Expression table: bic_expr
- Metadata: bic_meta


### Solution

```{r download_and_load}
## Define the remote URL and local folder
bic_url <- "https://github.com/DU-Bii/module-3-Stat-R/raw/master/stat-R_2021/data/TCGA_BIC_subset/"

bic_folder <- "~/m3-stat-R/TCGA-BIC_analysis"

## Download and load the expression data table
## Note: we use check.names=FALSE to avoid replacing hyphens by dots
## in sample names, because we want to keep them as in the 
## original data files. 
bic_expr_file <- download_only_once(
  url_base = bic_url, 
  file_name = "BIC_log2-norm-counts_edgeR_DEG_top_1000.tsv.gz",
  local_folder = bic_folder)
bic_expr <- read.delim(file = bic_expr_file, 
                       header = TRUE, 
                       row.names = 1,
                       check.names = FALSE)
# colnames(bic_expr)
# dim(bic_expr)
# View(head(bic_expr))

## Download the metadata file
bic_meta_file <- download_only_once(
  url_base = bic_url, 
  file_name = "BIC_sample-classes.tsv.gz",
  local_folder = bic_folder)
bic_meta <- read.delim(file = bic_meta_file, 
                       header = TRUE, 
                       row.names = 1,
                       check.names = FALSE)

```


## Exploring the metadata

### Exercise

Check the content of the metadata file by looking at the first rows, and count the number of samples per class. 

### Solution

```{r metadata_exploration}

## Show the head of the metadata table
kable(head(bic_meta, n = 10), caption = "First rows of the BIC metadata table")

## Number of samples per class
kable(sort(table(bic_meta$cancer.type), decreasing = TRUE), 
      caption = "Number of samples per class")

```


## Sorting samples by cancer class


Sort the expression and metadata tables so that the samples with the same class come together. This is a bit triccky so we provide immediately the solution, but you might attempt todo it in you way if you have time. 


Some tips:

    - The expression table has one row per gene and one column per sample, whereas the metadata file has one row per sample. 

    - You can use the function `order()` to obtain the indices of the metadata table by order of sample class. This will return a vector with all the indixes of the first class, then all the indices of the second class, etc. 
    
    - You can then use the indices of the dataframes to re-order them. 
    
    - We are not sure that the samples have the same order in the metadata and in the expression tables. So we will use the sample class to re-order the rows (samples) of the metadata file, but after this is done we will use the sample IDs of the metadata file (in the row names) in order to sort the columns of the expression table. This will guarantee that samples are in a consistent order between data and metadata tables.
    

### Solution

```{r sort_samples}
## Check that the row names of the metadata contain the same set 
## of IDs than the column names of the expression table
length(rownames(bic_meta)) ## the metadata contains 819 rows
length(colnames(bic_expr)) ## the data contains 819 columns
length(intersect(rownames(bic_meta), colnames(bic_expr))) ## Their intersection contains the same number of elements

## Get the sample order according to the cancer type column of the metadata
sample_order <- order(bic_meta$cancer.type)
print(bic_meta$cancer.type[sample_order])

## Sort the metadata rows (samples) according to this order
bic_meta <- bic_meta[sample_order, ]

## Sort the expression table to make sure that the samples (columns)
## come in the same order as the rows of the metadata table
bic_expr <- bic_expr[, row.names(bic_meta)]

```





