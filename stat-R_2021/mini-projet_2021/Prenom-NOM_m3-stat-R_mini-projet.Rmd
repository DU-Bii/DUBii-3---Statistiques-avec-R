---
title: "Mini-projet 2021 - Exploration des données de Pavkovic"
author: "Prénom Nom"
date: '`r Sys.Date()`'
output:
  html_document:
    self_contained: yes
    code_download: true
    fig_caption: yes
    highlight: zenburn
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: "hide"
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
editor_options: 
  chunk_output_type: console
---


```{r settings, include=FALSE, echo=FALSE, eval=TRUE}
options(width = 300)
# options(encoding = 'UTF-8')
knitr::opts_chunk$set(
  fig.width = 7, fig.height = 5, 
  fig.path = 'figures/mini-projet_',
  fig.align = "center", 
  size = "tiny", 
  echo = TRUE, 
  eval = TRUE, 
  warning = FALSE, 
  message = FALSE, 
  results = TRUE, 
  comment = "")

options(scipen = 12) ## Max number of digits for non-scientific notation
# knitr::asis_output("\\footnotesize")
```

```{r libraries, echo=FALSE, eval=TRUE}
#### Required libraries ####

# Load required CRAN R libraries
required_cranLib <- c("knitr", 
                      "FactoMineR", 
                      "factoextra", 
                      "gprofiler2",
                      "pheatmap")
for (lib in required_cranLib) {
  if (!require(lib, character.only = TRUE)) {
    install.packages(lib)
  }
  require(lib, character.only = TRUE)
}

required_biocLib <- c("biomaRt")
for (lib in required_biocLib) {
  if (!require(lib, character.only = TRUE)) {
    BiocManager::install(lib)
  }
  require(lib, character.only = TRUE)
}

kable(as.data.frame(c(required_cranLib, required_biocLib)),
      col.names = "libraries",
      caption = "Loaded required libraries"
    )

sessionInfo()
```

## Synopsis du projet

### Travail demandé

Le but de ce travail est de mettre en oeuvre les méthodes vues dans le module 3 "R et statistiques" pour explorer le jeu de données de Pavkovic, et de rendre un rapport d'analyse au format `.Rmd`. 

Nous fournissons ci-dessous une trame avec les principales sections attendues. Certaines contiennent déjà du code. Vous devrez en compléter d'autres. Sentez-vous libres d'adapter cette trame ou d'y ajouter des analyses complémentaires si elles vous aident à interpréter vos résultats. 

### Remise du rapport

Date: **le 17 mai 2021 minuit**.  Si vous anticipez un problème pour remettre le rapport à cette date contactez-nous aussi rapidement que possible pour que nous puissions prévoir une remise plus tardive. 

- Commencez par renommer le fichier .Rmd en remplaçant Prenom-NOM par vos nom et prénom. 
- Le rapport est attendu en formats .Rmd + .HTML (en gardant l'option self_contained de l'en-tête activée). 
- Déposez les fichiers dans un sous-dossier de vote compte du cluster. Attention, veillez à respecter précisément cette structure de chemin car nous nous baserons dessus pour récupérer vos résultats. 

    `/shared/projects/dubii2021/[login]/m3-stat-R/mini-projet` 

### Critères d'évaluation

- Reproductibilité des analyses: nous tenterons de regénérer le rapport HTML à partir de votre Rmd, en partant de notre compte sur le serveur IFB. 
- Manipulation des objets R
- Mobilisation des méthodes statistiques vues au cours
- Pertinence des interprétations statistiques
- Pertinence des interprétations biologiques
- Clarté de la rédaction
- Clarté des illustrations (figures et tableaux): graphismes, légendes ...

Nous vous encourageons à assurer la lisibilité de votre code (syntaxe, nommage des variables, commentaires de code)

### Objectifs scientifiques

Nous partons du même jeu de données *Fil Rouge* de ce module issues de la publication Pavkovic, M., Pantano, L., Gerlach, C.V. et al. Multi omics analysis of fibrotic kidneys in two mouse models. Sci Data 6, 92 (2019). https://doi.org/10.1038/s41597-019-0095-5

**Rappel sur les échantillons:**

Deux modèles de fibrose rénale chez la souris sont étudiés:

1. Le premier est un modèle de néphropathie réversible induite par l'acide folique (folic acid (FA)). Les souris ont été sacrifiées avant le traitement (normal), puis à jour 1, 2, 7 et 14 (day1,...) après une seule injection d'acide folique.

2. Le second est un modèle irréversible induit chrirurgicalement (unilateral ureteral obstruction (UUO)). les souris ont été sacrifiées avant obstruction (day 0) et à 3, 7 et 14 jours après obstruction par ligation de l'uretère du rein gauche.

A partir de ces extraits de rein, l'ARN messager total et les petits ARNs ont été séquencés et les protéines caratérisées par spectrométrie de masse en tandem (TMT).

**But scientifique:** Dans le tutoriel sur les dataframes, vous avez travaillé sur les données de ***transcriptome du modèle UUO***. Dans ce mini-projet, vous allez travailler sur les données du ***transcriptome du modèle FA*** afin de regrouper les observations (échantillon) et les gènes selon des profils d'expression similaires.

**Votre projet se décompose en 5 parties dont 3 seront à réaliser par:**

1. Statitiques descriptives des données brutes: commandes fournies
2. Normalisation des données : commandes fournies
3. Statistiques descriptives des données normalisées: à vous de jouer
4. Analyse de regroupement des données: à vous de jouer
5. Analyse d'enrichissement fonctionnel: à vous de jouer

## 1. Les données brutes

***Vous n'avez rien à coder ici. Le code est fourni.***

### Chargement des données brutes

Le bloc suivant contient une fonction qui permet de télécharger un fichier dans l'espace de travail, sauf s'il est déjà présent. Nous l'utiliserons ensuite pour télécharger les données à analyser en évitant de refaire le transfert à chaque exécution de l'analyse. 

```{r function_download_only_once}
#' @title Download a file only if it is not yet here
#' @author Jacques van Helden email{Jacques.van-Helden@@france-bioinformatique.fr}
#' @param url_base base of the URL, that will be prepended to the file name
#' @param file_name name of the file (should not contain any path)
#' @param local_folder path of a local folder where the file should be stored
#' @return the function returns the path of the local file, built from local_folder and file_name
#' @export©
download_only_once <- function(
  url_base, 
  file_name,
  local_folder) {

  ## Define the source URL  
  url <- file.path(url_base, file_name)
  message("Source URL\n\t",  url)

  ## Define the local file
  local_file <- file.path(local_folder, file_name)
  
  ## Create the local data folder if it does not exist
  dir.create(local_folder, showWarnings = FALSE, recursive = TRUE)
  
  ## Download the file ONLY if it is not already there
  if (!file.exists(local_file)) {
    message("Downloading file from source URL to local file\n\t", 
            local_file)
    download.file(url = url, destfile = local_file)
  } else {
    message("Local file already exists, no need to download\n\t", 
            local_file)
  }
  
  return(local_file)
}
```

Nous téléchargeons deux fichiers dans un dossier local `~/m3-stat-R/pavkovic_analysis` **(vous pouvez changer le nom ou chemin dans le chunk ci-dessous)**, et les chargeons dans les data.frames suivants: 

- Données brutes de transcriptome: `fa_expr_raw`
- Métadonnées: `fa_meta`

```{r download_and_load}
## Define the remote URL and local folder
pavkovic_url <- "https://github.com/DU-Bii/module-3-Stat-R/raw/master/stat-R_2021/data/pavkovic_2019/"

## Define the local folder for this analysis (where the data will be downloaded and the results generated)
pavkovic_folder <- "~/m3-stat-R/pavkovic_analysis"

## Define a sub-folder for the data
pavkovic_data_folder <- file.path(pavkovic_folder, "data")

## Download and load the expression data table
## Note: we use check.names=FALSE to avoid replacing hyphens by dots
## in sample names, because we want to keep them as in the 
## original data files. 
message("Downloading FA transcriptome file\t", "fa_raw_counts.tsv.gz",
  "\n\tfrom\t", pavkovic_url)
fa_expr_file <- download_only_once(
  url_base = pavkovic_url, 
  file_name = "fa_raw_counts.tsv.gz",
  local_folder = pavkovic_data_folder)

## Load the expresdsion table
message("Loading FA transcriptome data from\n\t", fa_expr_file)
fa_expr_raw <- read.delim(file = fa_expr_file, 
                       header = TRUE, 
                       row.names = 1)

## Download the metadata file
message("Downloading FA metadata file\t", "fa_transcriptome_metadata.tsv",
  "\n\tfrom\t", pavkovic_url)
fa_meta_file <- download_only_once(
  url_base = pavkovic_url, 
  file_name = "fa_transcriptome_metadata.tsv",
  local_folder = pavkovic_data_folder)

## Load the metadata
message("Loading FA metadata from\n\t", fa_meta_file)
fa_meta <- read.delim(file = fa_meta_file, 
                       header = TRUE, 
                       row.names = 1)
```

Nous regardons la structure de chaque dataframe.

```{r insepct data}
str(fa_expr_raw)
str(fa_meta)
```

Les deux fichiers ne donnent pas les observations de l'échantillon dans le même ordre:

```{r check data order}
fa_meta$sampleName == names(fa_expr_raw)
```

Nous les réorganisons les échantillons dans l'ordre de l'expérience: condition normale, puis day 1 à 14 avec les 3 réplicats.

```{r reoder data}
sample_order <- c(paste(rep(c("normal", "day1", "day2", "day3", "day7", "day14"), each = 3),
                        1:3, sep = "_"))

fa_expr_raw <- fa_expr_raw[,sample_order]
fa_meta <- fa_meta[match(sample_order, fa_meta$sampleName),]

# View(fa_meta)
kable(fa_meta, caption = "Metdata for Pavkovoc FA transcriptome")
```

=> Ainsi, nous avons un jeu de données avec un échantillon de `r nrow(fa_meta)` observations et des données d'expression de `r nrow(fa_expr_raw)` gènes.


### Statistiques descriptives

Dans le tutorial sur les dataframes sur le jeu de données "uuo" (relisez le corrigé), nous vous avons demandé de créer un data.frame qui collecte les statistiques par gène et par échantillon. Nous vous demandons de réaliser une étude similaire sur les données "FA" avant et après normalisation inter-échantillons des données. Le code de la partie avant normalisation est donné.

#### Par échantillon avant normalisation

Nous créons un data.frame nommé `sample_stat_prenorm` qui comporte une ligne par échantillon et une colonne par statistique. Nous calculons les statistiques suivantes sur les valeurs log2 d'expression de chaque échantillon:

- moyenne
- écart-type
- intervalle inter-quartiles
- premier quartile
- médiane
- troisième quartile
- maximum
- nombre de valeurs nulles

Il est affiché avec la fonction `kable()`. 

```{r sample_stat_pre_norm}
message("Computing sample-wise statistics on raw counts")
sample_stat_prenorm <- data.frame(
  mean = apply(fa_expr_raw, 2, mean, na.rm = TRUE),
  sd = apply(fa_expr_raw, 2, sd, na.rm = TRUE),
  iqr = apply(fa_expr_raw, 2, IQR, na.rm = TRUE),
  Q1 = apply(fa_expr_raw, 2, quantile, p = 0.25, na.rm = TRUE),
  median = apply(fa_expr_raw, 2, median, na.rm = TRUE),
  Q3 = apply(fa_expr_raw, 2, quantile, p = 0.75, na.rm = TRUE),
  max = apply(fa_expr_raw, 2, max, na.rm = TRUE),
  null = apply(fa_expr_raw == 0, 2, sum, na.rm = TRUE)
)

kable(sample_stat_prenorm, caption = "Sample-wise statistics before normalisation.")
```

#### Par gène avant normalisation

Nous créons ci-dessous un data.frame nommé `gene_stat_prenorm` qui comporte une ligne par gène et une colonne par statistique. Nous calculons les statistiques suivantes sur les valeurs log2 de chaque gène.

- moyenne
- médiane
- écart-type
- premier quartile
- troisième quartile
- maximum
- nombre de valeurs nulles
- intervalle inter-quartiles

Ces résultats sont stockés dans un data.frame avec 1 ligne par échantillon et 1 colonne par statistique. Nous affichons les lignes 100 à 109 de ce tableau de statistiques avec la fonction `kable()`.

```{r gene_stat_pre_norm}
## Gene-wise statistics for the raw counts (will be used for normalisation)
message("Computing gene-wise statistics on raw counts")
gene_stat_prenorm <- data.frame(
  mean = apply(fa_expr_raw, 1, mean, na.rm = TRUE),
  sd = apply(fa_expr_raw, 1, sd, na.rm = TRUE),
  iqr = apply(fa_expr_raw, 1, IQR, na.rm = TRUE),
  Q1 = apply(fa_expr_raw, 1, quantile, p = 0.25, na.rm = TRUE),
  median = apply(fa_expr_raw, 1, median, na.rm = TRUE),
  Q3 = apply(fa_expr_raw, 1, quantile, p = 0.75, na.rm = TRUE),
  max = apply(fa_expr_raw, 1, max, na.rm = TRUE),
  null = apply(fa_expr_raw == 0, 1, sum, na.rm = TRUE)
)

kable(gene_stat_prenorm[100:109, ], caption = "Gene-wise statistics before normalisation")
```

## 2. Filtrage et normalisation des données

***Vous n'avez rien à coder ici. Le code est fourni.***

Il existe plusieurs façons de normaliser les données de transcriptome  vues dans les modules 4 et 5 (cf. total counts, quantiles, TMM, RLE, limma voom,...), mais nous avons choisi ici une solution simple tout en étant robuste pour normaliser les données en standardisant le 3ème quantile. 

La méthode choisie ici consiste à :

1. **Ecarter les gènes "non-détectés"**, c'est-à-dire ceux ayant des valeurs nulles dans au moins 90% des échantillons.

2. **Ecarter les gènes à peine exprimés**, c'est-à-dire ceux ayant une valeur moyenne < 10 (arbitrairement).

3. **Standardiser les échantillons **sur le 3ème quartile des gènes restants: on divise les comptages bruts par le 3ème quartile de l'échantillon et on multiplie par le 3ème quartile de l'ensemble des échantillons.

4. **Normaliser les comptages** (au sens propre, c'est-à-dire rapprocher leur distribution de la distribution gaussienne) par une transformation logarithmique (log2). 

Nous fournissons ci-dessous le code.

### Filtrage : élimination des gènes non détectés ou à peine exprimés

```{r gene_filtering}
## Data filtering: genes having at least 90% null values
message("Filtering undetected genes")
undetected_genes <- gene_stat_prenorm$null >= ncol(fa_expr_raw) * 0.9
print(paste0("Undetected genes (null in >= 90% samples): ", sum(undetected_genes)))

## Data filtering: genes having a mean expression < 10
message("Filtering barely expressed genes")
barely_expressed_genes <- gene_stat_prenorm$mean < 10
print(paste0("Barely expressed genes (mean < 10): ", sum(barely_expressed_genes)))

## Apply filtering on both criteria
discarded_genes <- undetected_genes | barely_expressed_genes
print(paste0("Discarded genes: ", sum(discarded_genes)))
kept_genes <- !discarded_genes
print(paste0("Kept genes: ", sum(kept_genes)))

## Genes after filtering
fa_expr_filtered <- fa_expr_raw[kept_genes, ]

```




<!-- #### TMM via edgeR -->

<!-- Nous appliquons ici la normalisation sur base de la méthode TMM (Trimmed Mean of the M-values) développée par Robinson et Oshlack.  -->

<!-- - Robinson, M.D., Oshlack, A. A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biol 11, R25 (2010). <https://doi.org/10.1186/gb-2010-11-3-r25> -->



<!-- ```{r tmm_standardisation} -->
<!-- message("Standardising the counts wiht edgeR TMM method") -->

<!-- ## Create an edgeR object with the transcriptome data -->
<!-- d <- DGEList(counts = fa_expr_raw, group = fa_meta$condition) -->

<!-- ## Compute the normalisinfg factors with the TMM method -->
<!-- d <- calcNormFactors(d, method = "upperquartile") ## Compute normalizing factors -->
<!-- # d_tmm <- calcNormFactors(d, method = "TMM") ## Compute normalizing factors -->
<!-- # d_q3 <- calcNormFactors(d, method = "upperquartile") ## Compute normalizing factors -->
<!-- # plot(d_tmm$samples$norm.factors, d_q3$samples$norm.factors) -->
<!-- # cpm_q3 <- cpm(d_q3) -->
<!-- # apply(cpm(d_q3), 2, quantile, prob = 0.75) -->
<!-- # apply(cpm(d_tmm), 2, quantile, prob = 0.75) -->

<!-- ## Store the scaling factor in the metadata -->
<!-- fa_meta$scaling.factor <- d$samples$norm.factors -->

<!-- ## Create a separate data.frame with the standardised counts -->
<!-- fa_expr_tmm <- fa_expr_raw ## A quick way to have the same size and row names and column names -->
<!-- for (s in 1:ncol(fa_expr_tmm)) { -->
<!--   fa_expr_tmm[, s] <- fa_expr_raw[, s] / fa_meta$scaling.factor[s] -->
<!-- } -->
<!-- # range(fa_expr_tmm) -->
<!-- # mean(unlist(fa_expr_tmm)) -->
<!-- # q3_raw <- apply(fa_expr_raw, 2, quantile, prob = 0.75) -->
<!-- # q3_tmm <- apply(fa_expr_tmm, 2, quantile, prob = 0.75) -->
<!-- # plot(q3_raw, q3_tmm) -->
<!-- # summary(fa_expr_tmm) -->
<!-- ## Compute the log2-transformed counts after normalisation -->
<!-- fa_expr_tmm_log2 <- log2(fa_expr_tmm + epsilon) -->

<!-- boxplot(fa_expr_tmm_log2, horiz = TRUE) -->
<!-- ``` -->


### Standardisation entre échantillons

Nous appliquons ici une méthode simple mais efficace de standardisation

```{r normalisation_q3}
#### Inter-sample standardisation on the Q3 of raw counts ####
total_q3 <- quantile(unlist(fa_expr_filtered), probs = 0.75)
sample_stat_prenorm$Q3_filterd <- apply(fa_expr_filtered, 2, quantile, probs = 0.75)
sample_stat_prenorm$scale_factor <- 1 / sample_stat_prenorm$Q3_filterd * total_q3

## Apply standardisation
fa_expr_standard <- t(t(fa_expr_filtered) * unlist(sample_stat_prenorm$scale_factor))
## Check 3rd quantile after standardisation
kable(apply(fa_expr_standard, 2, quantile, probs = 0.75), 
      col.names = "Q3_standardised", 
      caption = "Third quartile of the filtered counts after inter-sample standardisation of the third quartiles. ")
# boxplot(fa_expr_standard, horizontal = TRUE)
```


<!-- ```{r sample_standardisation} -->
<!-- ## Generate a data frame where null values are replaced by NA -->
<!-- fa_expr_nonull <- fa_expr_log2_filtered -->
<!-- fa_expr_nonull[fa_expr_log2_filtered <= 0] <- NA -->
<!-- sum(is.na(fa_expr_nonull)) -->

<!-- ## Compute the 3rd quartile of non-null values for each sample and store them in a vector: -->
<!-- sample_q3_nonull <- apply(fa_expr_nonull, 2, quantile, prob = 0.75, na.rm = TRUE) -->
<!-- # print(sample_q3_nonull) -->

<!-- ## Compute the Q3 for all the values, which will serve as target value for the standardised sample Q3 -->
<!-- all_q3_nonull <- quantile(unlist(fa_expr_nonull), prob = 0.75, na.rm = TRUE) -->
<!-- # print(all_q3_nonull) -->

<!-- ## Standardise expression on the third quartile of non-null values -->
<!-- ## Beware : for this standardization we keep the null values -->
<!-- ## Trick : we transpose the table to apply the ratio sample per sample,  -->
<!-- ## and then transpose the results to get back the genes in rows and samples in columns -->
<!-- fa_expr_log2 <- t(t(fa_expr_log2_filtered) * all_q3_nonull / sample_q3_nonull ) -->
<!-- # quantile(unlist(fa_expr_log2), probs = 0.75, na.rm = TRUE) -->

<!-- ## We also compute the values for the "nonull" table for  -->
<!-- ## the sake of comparison and to check that the third quantiles of non-null  -->
<!-- ## values are well identical across samples. -->
<!-- fa_expr_log2_nonull <- t(t(fa_expr_nonull) * all_q3_nonull / sample_q3_nonull ) -->
<!-- # quantile(unlist(fa_expr_log2_nonull), probs = 0.75, na.rm = TRUE) -->

<!-- ## Compute Q3 before and after standardisation, including or not the null values -->
<!-- standardisation_impact <- data.frame( -->
<!--   before_all = apply(fa_expr_log2_filtered, 2, quantile, prob =  0.75, na.rm = TRUE), -->
<!--   before_nonull = apply(fa_expr_nonull, 2, quantile, prob =  0.75, na.rm = TRUE), -->
<!--   after_nonul = apply(fa_expr_log2_nonull, 2, quantile, prob =  0.75, na.rm = TRUE), -->
<!--   after_all = apply(fa_expr_log2, 2, quantile, prob =  0.75, na.rm = TRUE) -->
<!-- ) -->

<!-- ## Note: after standardization the Q3 of the data show some variations  -->
<!-- ## because we compute them here with the null values -->
<!-- kable(standardisation_impact, caption = "Impact of standardization on the third quantile (Q3) per sample. Third quantiles are computed before and after standardisation, with either all the values of the filtered table, or only the non-null values. ") -->
<!-- ``` -->


### Transformation log2

Nous appliquons une transformation en log2 des données brutes, après avoir ajouté un epsilon $\epsilon = 1$ (les valeurs nulles seront donc représentées par un log2(counts) valant $0$. Nous stockons le résultat dans un data.frame nommé `fa_expr_log2`.

Nous affichons un fragment des tableaux `fa_expr_raw` et `fa_expr_log2` en sélectionnant les lignes 100 à 109 et les colonnes 5 à 10, afin de nous assurer que la transformation en log2 a bien fonctionné. 

```{r log2_transform}
## Log2 transformation of the transcriptome data
epsilon <- 1
fa_expr_log2 <- log2(fa_expr_standard + epsilon)
# dim(fa_expr_log2)
# View(head(fa_expr_log2))

## Display of a fragment of the data before and after log2 transformation
kable(fa_expr_raw[100:109, 5:10], caption = "Fragment des données transcriptomiques brutes")
kable(fa_expr_log2[100:109, 5:10], caption = "Fragment des données transcriptomiques après transformation log2")
```

## 3. Statistiques descriptives sur les données normalisées

***A vous de jouer!***

### Statistiques par gène après normalisation

Générez un data.frame avec une ligne par gène à partir du tableau de données normalisées, avec les statistiques suivantes (une statistique par colonne):

- moyenne
- variance
- écart-type
- coefficient de variation (écart-type divisé par la moyenne)
- intervalle inter-quartiles
- minimum
- médiane
- maximum

```{r gene_stat_post_norm}
## Gene-wise statistics after normalisation
message("Computing gene-wise statistics on log2-transformed and normalised counts")
gene_stat_norm <- data.frame(
  mean = apply(fa_expr_log2, 1, mean, na.rm = F),
  var = apply(fa_expr_log2, 1, var, na.rm = TRUE),
  sd = apply(fa_expr_log2, 1, sd, na.rm = F),
  CV = NA,
  min = apply(fa_expr_log2, 1, min, na.rm = TRUE),
  Q1 = apply(fa_expr_log2, 1, quantile, p = 0.25, na.rm = TRUE),
  median = apply(fa_expr_log2, 1, median, na.rm = TRUE),
  Q3 = apply(fa_expr_log2, 1, quantile, p = 0.75, na.rm = TRUE),
  max = apply(fa_expr_log2, 1, max, na.rm = TRUE),
  null = apply(fa_expr_log2 == 0, 1, sum, na.rm = TRUE)
  )
gene_stat_norm$CV <- gene_stat_norm$sd / gene_stat_norm$mean
```

### Annotation des gènes

Chaque gène étant donné par son identifiant dans la base de données ENSEMBL vous utiliserez le `paquet biomaRt de bioconductor` pour ajouter des annotations : symbole, chromosome, coordonnées génomiques, brin. 
Suivez pas à pas la méthode proposée (***certaines étapes peuvent prendre quelques minutes***):

 - chargez le paquet biomaRt, voire installer-le uniquement si nécessaire. Indiquez le code à l'emplacement adéquat dans de .Rmd.

 - sélectionnez la base de données ENSEMBL avec la fonction `useMart()`. Attention à choisir le bon génome avec l'agument `dataset`: `mmusculus_gene_ensembl`
 
 - avec la fonction `getBM()` récupérez de la base de données ENSEMBL les champs demandés (***pour symbole utilisez external_gene_name***) en appliquant "ensembl_geneid" pour l'agument `filter` et en indiquant pour l'argument `values` le vecteur des identifiants des gènes présents dans le dataframe `gene_stat_norm`. Vous obtenez un dataframe.
 
A présent, ajoutez au dataframe `gene_stat_norm` en 1ères colonnes les annotations retrouvées grâce à biomaRt. Attention, certains gènes ne sont pas retrouvés dans la version d'ENSEMBL sur biomaRt donc laissez des NA comme données manquantes dans ce cas. Nous vous recommandons d'utiliser la function `merge()` de R base ou bien `left_join()` de `dplyr` pour fusionner les deux dataframes en un seul.
 
```{r gene_annotations}
### Gene annotations ####

## Open a connection to Ensembl MART
message("Opening connection to Ensembl MART")
ensembl <- useMart("ENSEMBL_MART_ENSEMBL", 
                   host = "www.ensembl.org", 
                   dataset = "mmusculus_gene_ensembl")

## Get gene annotations
message("Getting gene annotations")
genes <- getBM(attributes = c("ensembl_gene_id", 
                              "external_gene_name", 
                              "chromosome_name",
                              "start_position", 
                              "end_position", 
                              "strand"), 
               filter = "ensembl_gene_id",
               values = row.names(gene_stat_norm),
               mart = ensembl)
  
## Merge gene annotations and expression statistics
gene_stat_norm <- merge(genes, gene_stat_norm, by.x = "ensembl_gene_id", by.y = 0, sort = FALSE)

kable(gene_stat_norm[100:109, ], caption = "Gene-wise statistics after normalisation")
```

**Challenge falcultatif:**

Réordonnez les gènes par position génomique et affichez les lignes 5 premières et  5 dernières lignes de ce tableau de statistiques. 

```{r display fragment of gene-wise stats after norm}

gene_stat_norm <- gene_stat_norm[order(gene_stat_norm$chromosome_name, gene_stat_norm$start_position),]

kable(gene_stat_norm[c(1:5, (nrow(gene_stat_norm) - 4):nrow(gene_stat_norm)), ], 
      caption = "Gene-wise statistics after normalisation.")
```


### Distribution des données

- Dessinez sous forme d'un histogramme la distribution des valeurs après normalisation (tous échantillons confondus)

```{r fa_expr_norm_distrib, fig.width=8, fig.height=5, out.width="70%", fig.cap="Distribution of expression values (log2 counts) after gene filtering and standardisation on the sample-wise third-quartile of non-null values. The vertical line highlights the mean value. "}
hist(unlist(fa_expr_log2), 
     breaks = seq(from = 0, to = max(fa_expr_log2) + 1, by = 0.25),
     xlab = "log2(counts) after standardisation", 
     ylab = "number of genes after filtering",
     col = "#BBDDFF",
     las = 1, cex.axis = 0.8,
     main = "distribution after standardisation")
abline(v = mean(fa_expr_log2), col = "darkgreen", lwd = 2)
```

- Dessinez un box plot par échantillon avant et après normalisation, et commentez la façon dont l'effet de la normalisation apparaît sur ces graphiques. 

```{r boxplots_standardisation_impact, fig.width=10, fig.height=12, out.width="100%", fig.cap="Box plots showing the impact of normalisation"}
#### Box plots to show normalisation impact ####
par(mar = c(4,6,4,1)) ## Set the margins
par(mfrow = c(2,2))
boxplot(fa_expr_raw, 
        horizontal = TRUE,
        xlab = "counts", 
        las = 1, 
        col = fa_meta$color, 
        main = "Raw counts, all genes")
boxplot(fa_expr_filtered, 
        horizontal = TRUE, 
        xlab = "counts", 
        las = 1, 
        col = fa_meta$color, 
        main = "Raw counts, filtered genes")
boxplot(fa_expr_standard, 
        horizontal = TRUE, 
        xlab = "counts", 
        las = 1, 
        col = fa_meta$color, 
        main = "Standardised counts (sample Q3)")
boxplot(fa_expr_log2, 
        xlab = "log2(counts)", 
        las = 1, 
        horizontal = TRUE, 
        col = fa_meta$color, 
        main = "Normalised counts")
par(mfrow = c(1, 1))
par(mar = c(4,5,5,1))
```

## 4. Analyse de regroupement des données

***A vous de jouer!***

### Sélection de gènes d'expression élevée et variable

Pour réduire le nombre de gènes, nous allons écarter les gènes faiblement exprimés (log2 moyen inférieur à 4), et ne retenir que ceux qui montrent des variations importantes entre échantillons. Pour ce dernier critère, nous nous basons sur la variance. 

<!-- Sélectionnez les gènes ayant un niveau log2 moyen minimal supérieur à 3 ($m > 3$) et un coefficient de variation supérieur à 0.5 ($CV > 0.5$). Note: ces valeurs sont parfaitement arbitraires, elles ont été choisies pour obtenir un nombre raisonnable de gènes.  -->

Sélectionnez les gènes ayant un niveau log2 moyen minimal supérieur à 5 ($m > 5$) et une variance supérieure à 2 ($s^2 > 2$). Note: ces valeurs sont parfaitement arbitraires, elles ont été choisies pour obtenir un nombre raisonnable de gènes. 

```{r gene_selection}
## Compute a Boolean vector indicating whether each gene passes or not the expression level threshold
high_expression <- gene_stat_norm$mean > 5
# table(high_expression) # count number of genes with high/weak expression

## Compute a Boolean vector indicating whether each gene passes or not the variation coefficient threshold
high_variation <- gene_stat_norm$CV > 0.5
# table(high_variation) # count number of genes with weak high coeffficient of variation

## Compute a Boolean vector indicating whether each gene passes or not the variance threshold
high_variance <- gene_stat_norm$var > 2
# table(high_variance) # count number of genes with weak high variance

# ## Select genes having both a high mean expression and a high variation coefficien
# selected_genes <- high_variation & high_expression
## Select genes having both a high mean expression and a high variance
selected_genes <- high_variance & high_expression
# table(selected_genes) # count number of genes with weak high coeffficient of variation
print(paste0("Selected genes: ", sum(selected_genes)))

## Create a data frame with the expression of the selected genes
fa_expr_selected <- fa_expr_log2[selected_genes, ]
```

Dessinez des histogrammes des valeurs d'expression avant et après cette sélection de gènes, et commentez les différences. 

```{r hist_expr_selected_genes, fig.width=8, fig.height=6, out.width="100%", fig.cap="Distribution of expression values before and after gene selection"}
#### Histograms of expression before and after gene selection ####

par(mfrow = c(2,1))
hist(unlist(fa_expr_log2), 
     breaks = seq(from = 0, to = max(fa_expr_log2) + 1, by = 0.25),
     las = 1, 
     cex.axis = 0.8, 
     main = "Standardized values before gene selection",
     col =  "#DDBBFF")

hist(unlist(fa_expr_selected), 
     breaks = seq(from = 0, to = max(fa_expr_log2) + 1, by = 0.25),
     las = 1, 
     cex.axis = 0.8, 
     main = "Standardized values after gene selection",
     col =  "#FFDDBB")

par(mfrow = c(1,1))


# ## Some quick checks: the selection of highly variable genes select those having many zeros - and high values in other samples
# hist(unlist(fa_expr_log2_filtered[high_expression, ]), breaks=100)
# hist(unlist(fa_expr_log2_filtered[high_variation, ]), breaks=100)
# hist(unlist(fa_expr_log2_filtered[!high_variation, ]), breaks=100)
# hist(unlist(fa_expr_log2_filtered[selected_genes, ]), breaks=100)
```

Dessinez un box plot par échantillon des valeurs d'expression avant et après sélection des gènes, et commentez le résultat. 

```{r boxplots_expr_selected_genes, fig.width=10, fig.height=5, out.width="60%", fig.cap="Box plots of standardised expression values before and after gene selection. "}
#### Histogram of expression after gene selection ####

par(mfrow = c(1,2))

boxplot(fa_expr_log2, 
        horizontal = TRUE,
        xlab = "log2(counts)", 
        las = 1, 
        col = fa_meta$color, 
        main = "Before gene selection")
boxplot(fa_expr_selected, 
        horizontal = TRUE,
        xlab = "log2(counts)", 
        las = 1, 
        col = fa_meta$color, 
        main = "After gene selection")

par(mfrow = c(1,1))
```


### ACP

Dessinez un plot ACP des échantillons en les colorant par condition avant et après normalisation.

- avec les comptages bruts de la matrice d'expression initiale ($fa_expr$)

```{r acp_raw_all_genes, fig.width=8, fig.height=8, out.width="60%", fig.cap="PC plot of the samples from the raw expression values of all genes. "}
## Raw expression values, all genes
ma_pca_raw_tt <- PCA(t(fa_expr_raw), 
                      scale.unit = FALSE, 
                      graph = FALSE)
# plot(ma_pca_raw_tt, choix = "ind")
fviz_pca_ind(ma_pca_raw_tt, col.ind = fa_meta[,"condition"])
```

<!-- - avec les comptages bruts, mais en restreignant l'analyse aux gènes sélectionnés ($fa_expr_raw[selected_genes,]$) -->


<!-- ```{r acp_raw_selected_genes, fig.width=8, fig.height=8, out.width="60%", fig.cap="PC plot of the samples from the raw expression values of selected genes. "} -->
<!-- ## Raw values with only the selected genes -->
<!-- ma_pca_raw_sel <- PCA(t(fa_expr_raw[selected_genes,]),  -->
<!--                       scale.unit = FALSE,  -->
<!--                       graph = FALSE) -->
<!-- fviz_pca_ind(ma_pca_raw_sel, col.ind = fa_meta[, "color"]) -->
<!-- ``` -->


- avec la matrice de valeurs normalisées des gènes filtrés

```{r acp_norm_filtered_genes, fig.width=8, fig.height=8, out.width="60%", fig.cap="PC plot of the samples from normalised counts, before gene selection. "}
ma_pca_filtered <- PCA(t(fa_expr_log2), scale.unit = FALSE,
                  graph = FALSE)
# plot(ma_pca_filtered, choix = "var")
# plot(ma_pca_sel, choix = "ind")
fviz_pca_ind(ma_pca_filtered, col.ind = fa_meta[, "condition"])
```

- avec la matrice finale (transformation log2, filtre des gènes non-détectés, standardisation et sélection des gènes fortement exprimés et à haut coefficient de variation)

```{r acp_norm_selected_genes, fig.width=8, fig.height=8, out.width="60%", fig.cap="PC plot of the samples from normalised values, after gene selection. "}
ma_pca_sel <- PCA(t(fa_expr_selected), scale.unit = FALSE,
                  graph = FALSE)
# plot(ma_pca_sel, choix = "var")
# plot(ma_pca_sel, choix = "ind")
fviz_pca_ind(ma_pca_sel, col.ind = fa_meta[, "condition"])
```

### Clustering

- Calculez les matrices de distance entre échantillons, en utilisant respectivement les distances euclidienne (`dist()`), coefficient de Pearson (`cor(, method = "pearson")`)  et de Spearman (`cor(, method = "spearman")`).


```{r sample_distances}
#### Sample distances ####
dist_euc_samples <- dist(t(fa_expr_selected))
cor_pearson_samples <- as.dist(1 - cor(fa_expr_selected))
cor_spearman_samples <- as.dist(1 - cor(fa_expr_selected, method = "spearman"))
```

- Effectuez un clustering hiérarchique des échantillons, en utilisant le critère "complete" pour l'agglomération. Comparez les arbres d'échantillons obtenus avec ces trois métriques et choisissez celle qui vous paraît la plus pertinente.

```{r sample_clustering, fig.width=12, plot.height=5, out.width="100%", fig.cap="Sample tree with three alternative distance metrics: Euclidiant distance (left), Pearson correlation (center), Spearman correlation (right).? "}
#### Sample clustering ####
par(mfrow = c(1,3))
plot(hclust(dist_euc_samples), hang = -1,
     main = "euclidean distance")
plot(hclust(cor_pearson_samples), hang = -1,
     main = "pearson")
plot(hclust(cor_spearman_samples), hang = -1,
     main = "spearman")
par(mfrow = c(1,1))
```

- Effectuez un clustering hiérarchique des gènes en utilisant la distance basée sur le coefficient de Pearson et le critère de Ward

```{r gene_tree}
#### Gene tree with Pearson correlation ####
clustering_method <- "complete" ## Choose a clustering method
cor_pearson_genes <-  as.dist(1 - cor(t(fa_expr_selected)))

## Build a gene tree
gene_tree_pearson <- hclust(cor_pearson_genes, method = clustering_method)

## Plot the gene tree
plot(gene_tree_pearson, hang = -1, las = 1, 
     main = paste0("Gene tree; Pearson coefficient; ", clustering_method, " clustering"), 
     labels = FALSE)
```

- Dessinez un arbre avec le résultat du clustering des gènes et commentez sa structure. Si vous deviez choisir de façon arbitraire un nombre de clusters, que choisiriez-vous ? Pourquoi ? Pas de panique, nous pouvons assumer ici que la réponse comporte une part de subjectivité. 

```{r gene_tree_with_boxes}
#### Plot the gene tree with boxes to denote the clusters ####
plot(gene_tree_pearson, hang = -1,
     main = paste0("Gene tree with 7 clusters; Pearson coefficient; ", clustering_method, " clustering"), 
     labels = FALSE)
rect.hclust(gene_tree_pearson, k = 7)
```

- Dessinez une heatmap du résultat, en sélectionnant les deux résultats de clustering ci-dessus pour les gènes et les échantillons. 

```{r heatmap_biclustering, fig.width=10, fig.height=8, out.width="90%", fig.cap="Heatmap showing the biclustering of genes and samples. "}
#### Heatmap ####
pheatmap(t(fa_expr_selected), 
         main = paste0("Biclustering; ", "Pearson correlation; ", clustering_method, " clustering"),
         labels_col = "", 
         clustering_method = clustering_method, 
         clustering_distance_cols = "correlation", 
         clustering_distance_rows = "correlation")
```

- Dessinez une heatmap du résultat, en affichant un arbre sur les gènes mais pas sur les échantillons

```{r biclustering}
pheatmap(t(fa_expr_selected), 
         main = paste0("Gene clustering; ", "Pearson correlation; ", clustering_method, " clustering"),
         labels_col = "", 
         clustering_method = clustering_method, 
         clustering_distance_cols = "correlation", 
         cluster_rows = FALSE)
```


Interprétez les résultats en quelques phrases. 


## 5. Enrichissement fonctionnel

***A vous de jouer!***

Effectuez une analyse d'enrichissement fonctionnel avec les principaux clusters obtenus dans la section précédente. 

```{r functional_enrichment}
#### Run enrichment analysis with gost() ####
message("Running enrichment analysis with gost")

gene_list <- unlist(subset(x = gene_stat_norm, 
                    subset = selected_genes,
                    select = external_gene_name))
# length(gene_list)

gostres <- gost(query = gene_list, 
                organism = "mmusculus", 
                ordered_query = FALSE, 
                multi_query = FALSE, 
                significant = TRUE, 
                exclude_iea = FALSE, 
                measure_underrepresentation = FALSE, 
                evcodes = FALSE, 
                user_threshold = 0.05, 
                correction_method = "fdr", 
                domain_scope = "annotated", 
                custom_bg = NULL, 
                numeric_ns = "", 
                sources = NULL, 
                as_short_link = FALSE)


## Check the structure of the result
names(gostres)
names(gostres$result)
kable(summary(gostres))

# Visualization
gostplot(gostres, capped = TRUE, interactive = TRUE)

# hist(gostres$result$p_value, breaks=seq(from=0, to=1, by = 0.05))

## Check the most significant results, formating for kable
#head(gostres$result)
enrich_order <- order(gostres$result$p_value, decreasing = FALSE)
sorted_result <- gostres$result[enrich_order, ]
kable(head(sorted_result, n = 10), 
      digits = c(0, 0, 15, 7, 7, 7, 3, 3, 0, 0, 7, 7, 0, 0), 
      caption = "Top 10 most significant enriched functional classes")
# kable(head(gostres$result), 
#       format = c("%s", "%s", "%e", "%d", "%d", "%d", "%.3f", "%.3f", "%s", "%s", "%d", "%d", "%s", "%s"))
names(gostres$meta)
```

## Conclusions générales


Résumez en quelques phrases vos conclusions à partir des résultats obtenus. 



